/// @file system/details/array_view.h
#pragma once

#include <system/details/collections_helper.h>
#include <system/details/stack_array.h>
#include <system/select_type.h>
#include <system/smart_ptr.h>
#include <system/exceptions.h>

#include <utility>

namespace System { namespace Details {

    /// Helper class. Represent NON-SAFE lightweight wrapper around arrays generated on the stack (via CsToCppPorter.CppArrayOnStack attribute) and on the heap System::ArrayPtr<T>
    /// Generated by the porter via attribute CsToCppPorter.CppArgumentKind(ArgumentKind.ArrayView)
    /// Partially mimic to System::ArrayPtr<T> interface.
    /// Restriction: Only for 1D array's
    /// Intend to speed up element access and support arrays created on the stack.
    template<typename T>
    class ASPOSECPP_SHARED_CLASS ArrayView
    {
        enum {
            NullArrayViewLength = -1
        };
    public:
        /// Alias for the type of the elements of the array.
        using ValueType = T;
        /// Alias for the type used to represent each element of the array.
        using UnderlyingType = typename System::Details::SelectType<T>::type;

        /// Conversion constructor for std::array<T>
        template<std::size_t N>
        ArrayView(System::Details::StackArray<T, N> &arr)
            : m_data(arr.data())
            , m_length(static_cast<int32_t>(arr.size()))
        {
        }

        /// Conversion constructor for System::ArrayPtr<T>
        ArrayView(System::ArrayPtr<T> const &arr)
        {
            if (arr) {
                m_data = arr->data_ptr();
                m_length = arr->get_Length();
            }
            else {
                m_data = nullptr;
                m_length = NullArrayViewLength;
            }
        }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        inline int32_t get_Length() const { return m_length; }

        /// Returns a number that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        int Count() const { return get_Length(); }

        /// Returns the lower bound of the specified dimension.
        /// @param dimension Dimension to return the lower bound of
        /// @returns The lower bound of the specified dimension
        int GetLowerBound(int dimension) const
        {
            ASPOSE_UNUSED(dimension);
            return 0;
        }

        /// Returns the number of elements in the specified dimension.
        /// @param dimension A dimension the length of which to return
        /// @returns Number of elements in the specified dimension
        int GetLength(int dimension) const
        {
            ASPOSE_UNUSED(dimension);
            return m_length;
        }

        /// Returns a reference to the internal data structure used to store the array elements.
        inline UnderlyingType* data() const { return m_data; }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline UnderlyingType* begin() const noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline UnderlyingType* end() const noexcept
        {
            return m_data + m_length;
        }

        /// Returns an item at the specified index.
        /// @param index Index of the item to return
        /// @returns A reference to an item at specified position
        inline UnderlyingType& operator[](int index) const { return m_data[index]; }
        
        inline bool operator == (std::nullptr_t) const { return NullArrayViewLength == m_length; }
        inline bool operator != (std::nullptr_t) const { return NullArrayViewLength != m_length; }

        inline bool operator !() const noexcept { return NullArrayViewLength == m_length; }

        /// Returns 'this' pointer. Needs for compatibility with the porter code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline ArrayView<T>* operator -> (){ return this; }

        /// Copies a specified number of elements from the current array starting at specified position to specified
        /// destination array. Elements are inserted into the destination array starting at index specified by dstIndex
        /// argument.
        /// @param dstArray Destination array
        /// @param srcIndex Index in source array to start copying items at
        /// @param dstIndex Index in destination array to start inserting copied items at
        /// @param count Number of elements to copy
        /// @tparam DstType Type of elements in destination array
        template<typename DstType>
        void CopyTo(System::ArrayPtr<DstType> const &dstArray, int64_t srcIndex, int64_t dstIndex, int64_t count) const
        {
            namespace ns_helper = System::Collections::Generic::Details;

            if (!dstArray) {
                throw ArgumentNullException(u"dstArray");
            }
            if (srcIndex < 0 || dstIndex < 0 || count < 0) {
                throw ArgumentOutOfRangeException(u"srcIndex, dstIndex or count");
            }
            if (srcIndex + count > get_Length()
                || ns_helper::IsOutOfSize(dstIndex + count, dstArray->data())) {
                throw ArgumentException(u"srcIndex, dstIndex or count");
            }

            if (dstArray->data().data() == data() && dstIndex > srcIndex && dstIndex < srcIndex + count)
            {
                std::copy_backward(
                    m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex)
                    , m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                    , dstArray->data().begin() + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, dstIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                );
            }
            else
            {
                std::copy(
                    m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex)
                    , m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                    , dstArray->data().begin() + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, dstIndex)
                );
            }
        }

        /// Copies a specified number of elements from the current array starting at specified position to specified
        /// destination array view. Elements are inserted into the destination array view starting at index specified by dstIndex
        /// argument.
        /// @param dstArray Destination array view
        /// @param srcIndex Index in source array to start copying items at
        /// @param dstIndex Index in destination array view to start inserting copied items at
        /// @param count Number of elements to copy
        /// @tparam DstType Type of elements in destination array view
        template<typename DstType>
        void CopyTo(ArrayView<DstType> const &dstArray, int64_t srcIndex, int64_t dstIndex, int64_t count) const
        {
            if (!dstArray) {
                throw ArgumentNullException(u"dstArray");
            }
            if (srcIndex < 0 || dstIndex < 0 || count < 0) {
                throw ArgumentOutOfRangeException(u"srcIndex, dstIndex or count");
            }
            if (srcIndex + count > get_Length()
                || dstIndex + count > dstArray.get_Length()) {
                throw ArgumentException(u"srcIndex, dstIndex or count");
            }

            if (dstArray.data() == data() && dstIndex > srcIndex && dstIndex < srcIndex + count)
            {
                std::copy_backward(
                    m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex)
                    , m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                    , dstArray.m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, dstIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                );
            }
            else
            {
                std::copy(
                    m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex)
                    , m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, srcIndex) + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, count)
                    , dstArray.m_data + ASPOSECPP_CHECKED_CAST(std::ptrdiff_t, dstIndex)
                );
            }
        }

    private:
        /// Pointer to array
        UnderlyingType * m_data;
        /// Data length
        int32_t m_length;
    };

    template<typename T>
    bool operator == (std::nullptr_t, const ArrayView<T> &av) {
        return av == nullptr;
    }

    template<typename T>
    bool operator != (std::nullptr_t, const ArrayView<T> &av) {
        return av != nullptr;
    }

} }
