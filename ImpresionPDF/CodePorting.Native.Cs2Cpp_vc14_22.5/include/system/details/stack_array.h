#pragma once

#include <cstddef>
#include <cstdint>

namespace System { namespace Details {

    template<typename T, std::size_t ... NN>
    struct StackArray;


    /// Represents 1D array on the stack.
    /// Generated by the porter via attribute CsToCppPorter.CppArrayOnStack
    /// Partially mimic to System::ArrayPtr<T> interface.
    template<typename T, std::size_t N>
    struct StackArray<T, N>
    {
        using type_t = T[N];

        inline T& operator[] (std::size_t n) { return m_data[n]; }
        inline const T& operator[] (std::size_t n) const { return m_data[n]; }

        static const std::size_t size_ = N;
        constexpr std::size_t size() const noexcept { return size_; }
        constexpr std::size_t dims() const noexcept { return 1; }

        inline T * data() { return m_data; }
        inline const T * data() const { return m_data; }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        constexpr inline int32_t get_Length() const { return static_cast<int32_t>(size()); }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline T* begin() noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline T* end() noexcept
        {
            return m_data + N;
        }

        /// Returns an iterator to the first element of the container.
        /// @returns An pointer to first element of the container.
        inline const T* begin() const noexcept
        {
            return m_data;
        }

        /// Returns an iterator to the element following the last element of the container.
        /// @returns An pointer to the theoretical element placed after the last element of the container.
        inline const T* end() const noexcept
        {
            return m_data + N;
        }

        /// Returns 'this' pointer. Needs for compatibility with the porter code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline StackArray<T, N>* operator -> () { return this; }

        type_t m_data;
    };

    //...................................................................................

    /// Represents ND array on the stack. (for future expanding CsToCppPorter.CppArrayOnStack attribute)
    /// Partially mimic to System::ArrayPtr<T> interface.
    template<typename T, std::size_t N, std::size_t ... NN>
    struct StackArray<T, N, NN...>
    {
        static_assert(N != 0, "At least one dimension should be defined!");

        using StackArray_1D = typename StackArray<T, NN...>::type_t;
        using type_t = StackArray_1D[N];

        inline StackArray_1D& operator[] (std::size_t n) { return m_data[n]; }
        inline const StackArray_1D& operator[] (std::size_t n) const { return m_data[n]; }

        static const std::size_t size_ = N * StackArray<T, NN...>::size_;
        constexpr std::size_t size() const noexcept { return size_; }
        constexpr std::size_t dims() const noexcept { return sizeof ...(NN) + 1; }

        inline T * data() { return reinterpret_cast<T*>(m_data); }
        inline const T * data() const { return reinterpret_cast<const T*>(m_data); }

        /// Returns 32-bit integer that represents the total number of all elements in all dimensions of the array.
        /// @returns Total number of all elements in all dimensions
        constexpr inline int32_t get_Length() const { return size(); }

        /// Returns 'this' pointer. Needs for compatibility with the porter code generator to avoid create special cases.
        /// @returns A 'this' pointer
        inline StackArray<T, N, NN...>* operator -> () { return this; }

        type_t m_data;
    };

}}
